syntax = "proto3";

package replicator;

option go_package = "github.com/pkt-cash/pktd/lnd/lnrpc/protos/replicator";

import "protos/DB/tokendb.proto";
import "google/protobuf/empty.proto";

// Is mainly used to generate compatible querier (client)
//
// Generated client can be used to serve two main purposes:
//  - to interact with it via generated client
//  - to test generated client implementation by mocking generated server
//
service Replicator {
    // Returns available token offers
    rpc GetTokenOffers (GetTokenOffersRequest) returns (GetTokenOffersResponse);

    // Returns current token balances
    rpc GetTokenBalances (GetTokenBalancesRequest)
        returns (GetTokenBalancesResponse);

    // Verifies a user permitions to issue a token. Returns exceptions if
    // passed user is not contained in issuer's db
    rpc VerifyIssuer (VerifyIssuerRequest) returns (google.protobuf.Empty);

    // IssueToken — Issue new token with given data. Request data equal to
    // token purchase data, because it is token offer.
    rpc IssueToken(IssueTokenRequest) returns (google.protobuf.Empty);

    rpc SaveBlock(SaveBlockRequest) returns (google.protobuf.Empty);

    rpc GetHeaders(GetHeadersRequest) returns (GetHeadersResponse);

    rpc GetToken(GetTokenRequest) returns (GetTokenResponse);

    // GetTokenList — return list of issued token with infomation about
    // expiration time and fix price.
    rpc GetTokenList(GetTokenListRequest)
        returns(GetTokenListResponse);

}

message GetTokenOffersRequest {
    string issuer_id = 1;
    Pagination params = 2;
}

message GetTokenOffersResponse {
    repeated TokenOffer offers = 1;
    uint64 total = 2;
}

// GetTokenListRequest — request token list with pagination
message GetTokenListRequest {
    // issuer_id is user login issued this token
    string issuer_id = 1;
    // params of paginaton
    replicator.Pagination params = 2;
    // local its provide getting data from local database
    bool local = 3;
}

// GetTokenListResponse — list of tokens with additional info
message GetTokenListResponse {
    // tokens list of registred tokens
    repeated Token tokens = 1;
    // total number of registered tokens, if the issued_id is passed, only
    // its tokens are taken into account
    int32 total = 2;
}

message Token {
    string name = 1;
    // offer on token issue
    tokendb.Token token = 2;

    string root = 3;
}

message TokenOffer {
    string token = 1;

    // TODO: discuss
    //  ? Should we assume decimal prices
    //  ? Add units field
    uint64 price = 2;

    IssuerInfo issuer_info = 3;

    // It is assumed that the each registered token holder login is unique
    //
    // Value of this field may be empty orRegisterTokenHolder filled depending
    // on context (e.g. gettokenoffers, verifytokenpurchasesignature)
    string token_holder_login = 4;

    // It is assumed that the each registered token holder login is unique
    //
    // Value of this field may be empty or filled depending on context
    // (e.g. gettokenoffers, verifytokenpurchasesignature)
    string token_buyer_login = 5;

    // This field protects issuers from such a case, when potential buyer
    // successfully acquires dozens of signatures just in case if that issuer
    // would raise up the price later. If a Token Wallet holder would like to
    // open channel with an outdated offer, Replicator would reject to register
    // this purchase and buyer stays unprotected
    int64 valid_until_seconds = 6;

    // count — the number of tokens to be issued
    uint64 count = 7;
}

message IssuerInfo {
    // This value is explicetely used by Replicator to uniquely identify related
    // issuer later in order to ban him (discredite case), since
    // "identity_pubkey", "host" may be changed
    string id = 1;

    // The following field values are used to open payment channel, invoices
    // commands execution etc.
    string identity_pubkey = 2;

    // Is used to establish client connection to the issuer's node during some
    // RPC calls
    string host = 3;
}

// NOTE: we don't provide any token holder identification since the reqeuest is
// authorized with JWT applied to the request metadata. It means, that
// replicator is capable to extract all data needed to process the request
message GetTokenBalancesRequest {
    Pagination params = 1;
}

message GetTokenBalancesResponse {
    repeated TokenBalance balances = 1;
    uint64 total = 2;
}

message TokenBalance {
    string token = 1;
    uint64 available = 2;
    uint64 frozen = 3;
}

message Pagination {
    uint64 limit = 1;
    uint64 offset = 2;
}

message VerifyIssuerRequest {
    string login = 1;
}

// IssueTokenRequest — info about token will be issued
message IssueTokenRequest {
    string name = 1;
    // offer on token issue
    tokendb.Token offer = 2;
}

message SaveBlockRequest {
    string name = 1;

    tokendb.Block block = 2;
}

message GetTokenRequest {
    string token_id = 1;
}

message GetTokenResponse {
    Token token = 1;
}

message GetHeadersRequest {
    string token_id = 1;
    string hash = 2;
}

message GetHeadersResponse {
    tokendb.Token token = 1;
    repeated MerkleBlock blocks = 2;
}

message MerkleBlock {
    string hash = 1;
    string prev_hash = 2;
}